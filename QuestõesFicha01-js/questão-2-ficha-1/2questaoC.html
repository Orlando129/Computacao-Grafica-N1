<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Questão C — Reflexão (x−y=1) → Rot(30°) em (t,0,−t)</title>
  <style>
    html, body { height:100%; margin:0; background:#0b1020; color:#e6edf3; font-family: system-ui, sans-serif; }
    canvas { display:block; }
    #hud{ position:fixed; top:10px; left:10px; z-index:10; display:grid; gap:8px; grid-template-columns:1fr; max-width:92vw; }
    .card{ background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.18); border-radius:10px; padding:10px 12px; font-size:13px; line-height:1.35; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; overflow:auto; max-height:24vh; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .tag{ padding:2px 6px; border-radius:6px; background:#24314d; border:1px solid #334; font-size:12px; }
    .btn{ background:#1b2336; color:#e6edf3; border:1px solid #334; border-radius:8px; padding:6px 10px; cursor:pointer; }
    .btn:hover{ background:#24314d; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
<div id="hud">
  <div class="card">
    <div class="row">
      <span class="tag"><b>Questão C</b></span>
      Reflexão no plano <i>x−y=1</i> → Rot(30°) em torno da reta (t,0,−t) (sentido (1,0,−1))
    </div>
    <div class="row" style="margin-top:6px">
      <button class="btn" id="btnOnlyC">Aplicar somente C</button>
      <button class="btn" id="btnSeq">Rodar sequência A → B → C</button>
    </div>
  </div>
  <div class="card mono" id="mat-ref"></div>
  <div class="card mono" id="mat-rotc"></div>
  <div class="card mono" id="mat-comp"></div>
  <div class="card mono" id="mat-cur"></div>
</div>
<canvas id="c"></canvas>

<script>
(function(){
  // ===== cena =====
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
  const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b1020);
  const camera = new THREE.PerspectiveCamera(55, 2, 0.1, 1000); camera.position.set(6,5,9);
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const dl = new THREE.DirectionalLight(0xffffff, 0.9); dl.position.set(6,12,8); scene.add(dl);
  scene.add(new THREE.AxesHelper(4));

  // ===== util =====
  const deg2rad = d=>d*Math.PI/180;
  function matToString(m){
    const e=m.elements, get=(r,c)=>e[c*4+r]; let out='';
    for(let r=0;r<4;r++){ const row=[]; for(let c=0;c<4;c++) row.push((get(r,c)).toFixed(3).padStart(9)); out+='[ '+row.join(' ')+' ]\n'; }
    return out;
  }
  function T(tx,ty,tz){ return new THREE.Matrix4().makeTranslation(tx,ty,tz); }
  function S(sx,sy,sz){ return new THREE.Matrix4().makeScale(sx,sy,sz); }
  function R_axis(axis, ang){ return new THREE.Matrix4().makeRotationAxis(axis.clone().normalize(), ang); }
  function H_rot_about_point(axis, ang, P){
    return new THREE.Matrix4().multiplyMatrices(T(P.x,P.y,P.z), new THREE.Matrix4().multiplyMatrices(R_axis(axis,ang), T(-P.x,-P.y,-P.z)));
  }

  // ===== MATRIZES DA LETRA C =====
  // Reflexão no plano x - y = 1: traduz p/ origem por a=(1,0,0), reflete no plano x=y (troca x<->y), traduz de volta.
  const a = new THREE.Vector3(1,0,0);
  const R_swapXY = new THREE.Matrix4().set(
    0,1,0,0,
    1,0,0,0,
    0,0,1,0,
    0,0,0,1
  );
  const H_ref = new THREE.Matrix4().multiplyMatrices( T(a.x,a.y,a.z), new THREE.Matrix4().multiplyMatrices(R_swapXY, T(-a.x,-a.y,-a.z)) );

  // Rotação (30°) em torno da reta (t,0,-t): eixo u=(1,0,-1), passa pela origem
  const uC = new THREE.Vector3(1,0,-1).normalize();
  const H_rotC = R_axis(uC, deg2rad(30));

  // Operador composto da C: primeiro reflexão, depois rotação
  const H_C = new THREE.Matrix4().multiplyMatrices(H_rotC, H_ref);

  // ----- HUD fixo de C
  document.getElementById('mat-ref').textContent  = 'H_ref = T(a) · swapXY · T(−a), a=(1,0,0)\n' + matToString(H_ref);
  document.getElementById('mat-rotc').textContent = 'H_rotC = R_{(1,0,−1)}(30°)\n' + matToString(H_rotC);
  document.getElementById('mat-comp').textContent = 'H_C = H_rotC · H_ref\n' + matToString(H_C);

  // ===== FIGURA =====
  const square0 = new THREE.Mesh( new THREE.PlaneGeometry(1,1), new THREE.MeshStandardMaterial({ color:0x5BFFB5, side:THREE.DoubleSide, roughness:0.7 }) );
  scene.add(square0);
  const squareX = new THREE.Mesh( new THREE.PlaneGeometry(1,1), new THREE.MeshStandardMaterial({ color:0xFFD166, side:THREE.DoubleSide, roughness:0.7 }) );
  scene.add(squareX);

  // ===== MATRIZES DE A e B (para a sequência) =====
  // A: rotação do arco A→B centrado em C=(0,-1,-1)
  const A_pt = new THREE.Vector3( 2,-2,-3 );
  const B_pt = new THREE.Vector3( 2, 1, 0 );
  const Cc   = new THREE.Vector3( 0,-1,-1 );
  const uA = A_pt.clone().sub(Cc), vA = B_pt.clone().sub(Cc);
  const thetaAB = uA.angleTo(vA); // ~90°
  const kA = new THREE.Vector3().crossVectors(uA, vA).normalize();
  function H_A_t(t){ return H_rot_about_point(kA, thetaAB*t, Cc); } // t∈[0,1]

  // B: Rot(30°, eixo (1,-1,1) em P0=(-1,1,0)) → Escala(3,-2,0.5) → Trans(1,-2,-3)
  const axisB = new THREE.Vector3(1,-1,1).normalize();
  const P0B   = new THREE.Vector3(-1,1,0);
  const HB_rot = H_rot_about_point(axisB, deg2rad(30), P0B);
  const HB_s   = S(3,-2,0.5);
  const HB_t   = T(1,-2,-3);
  const HB_final = new THREE.Matrix4().multiplyMatrices(HB_t, new THREE.Matrix4().multiplyMatrices(HB_s, HB_rot));
  // versões interpoladas:
  function HB_rot_t(t){ return H_rot_about_point(axisB, deg2rad(30)*t, P0B); }
  function HB_s_t(t){ const sx=1+(3-1)*t, sy=1+(-2-1)*t, sz=1+(0.5-1)*t; return S(sx,sy,sz); }
  function HB_t_t(t){ return T(1*t, -2*t, -3*t); }
  function H_B_t(t1,t2,t3){ // t1,t2,t3 ∈ [0,1]
    return new THREE.Matrix4().multiplyMatrices(HB_t_t(t3), new THREE.Matrix4().multiplyMatrices(HB_s_t(t2), HB_rot_t(t1)));
  }

  // ===== enquadramento =====
  function resize(){ const w=innerWidth,h=innerHeight; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); }
  function frameAll(pad=1.35){
    const box=new THREE.Box3().setFromObject(scene);
    const size=box.getSize(new THREE.Vector3()), center=box.getCenter(new THREE.Vector3());
    const maxSize=Math.max(size.x,size.y,size.z);
    const fitH=maxSize/(2*Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5)));
    const fitW=fitH/camera.aspect;
    const d=pad*Math.max(fitH,fitW);
    camera.position.set(center.x+d, center.y+d*0.6, center.z+d);
    camera.lookAt(center);
  }
  addEventListener('resize', ()=>{ resize(); frameAll(); });
  resize(); frameAll();

  // ===== animação =====
  const clock = new THREE.Clock();
  let mode = 'SEQ'; // 'C' | 'SEQ'
  document.getElementById('btnOnlyC').onclick = ()=>{ mode='C'; t=0; };
  document.getElementById('btnSeq').onclick   = ()=>{ mode='SEQ'; t=0; };

  // tempos
  const TA=3.0, TB1=2.0, TB2=2.0, TB3=2.0, TC=3.0; // rotação A (3s), B em 3 fases (2s cada), C (3s)
  const TTOT = TA+TB1+TB2+TB3+TC;
  let t = 0;

  function onlyC(){
    // reflexão instantânea, rotação de 0→30° contínua em loop
    const tt = (t % TC) / TC;
    const Hcur = new THREE.Matrix4().multiplyMatrices(R_axis(new THREE.Vector3(1,0,-1), deg2rad(30)*tt), H_ref);
    squareX.matrixAutoUpdate = false; squareX.matrix.copy(Hcur);
    document.getElementById('mat-cur').textContent = 'H_cur (Somente C)\n' + matToString(Hcur);
  }

  function seqABC(){
    const tm = t % TTOT;
    let Hcur = new THREE.Matrix4().identity();

    if (tm < TA) {
      // Fase A: 0→thetaAB
      const p = tm/TA;
      Hcur.copy( H_A_t(p) );
    } else if (tm < TA+TB1) {
      // B-1: só rotação
      const p1 = (tm-TA)/TB1;
      Hcur.copy( H_B_t(p1,0,0) );
    } else if (tm < TA+TB1+TB2) {
      // B-2: rotação finalizada + escala 0→alvo
      const p2 = (tm-(TA+TB1))/TB2;
      Hcur.copy( H_B_t(1,p2,0) );
    } else if (tm < TA+TB1+TB2+TB3) {
      // B-3: rotação+escala feitos + translação 0→alvo
      const p3 = (tm-(TA+TB1+TB2))/TB3;
      Hcur.copy( H_B_t(1,1,p3) );
    } else {
      // C: reflexão instantânea + rotação 0→30°
      const pC = (tm-(TA+TB1+TB2+TB3))/TC;
      const Hrot = R_axis(new THREE.Vector3(1,0,-1), deg2rad(30)*pC);
      Hcur.multiplyMatrices(Hrot, H_ref);
    }

    squareX.matrixAutoUpdate = false; squareX.matrix.copy(Hcur);
    document.getElementById('mat-cur').textContent = 'H_cur (Sequência A→B→C)\n' + matToString(Hcur);
  }

  function loop(){
    const dt = clock.getDelta(); t += dt;
    if (mode==='C') onlyC(); else seqABC();
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
