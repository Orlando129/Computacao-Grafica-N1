<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Isneique — Espiral em D + Reflexões por A/B no plano C</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;color:#e6edf3;font-family:system-ui,sans-serif}
    canvas{display:block}
    #hud{position:fixed;top:10px;left:10px;z-index:10;display:grid;gap:8px;grid-template-columns:1fr;max-width:92vw}
    .card{background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.18);border-radius:10px;padding:10px 12px;font-size:13px;line-height:1.35}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;white-space:pre;overflow:auto;max-height:26vh}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .tag{padding:2px 6px;border-radius:6px;background:#24314d;border:1px solid #334;font-size:12px}
    .btn{background:#1b2336;color:#e6edf3;border:1px solid #334;border-radius:8px;padding:6px 10px;cursor:pointer}
    .btn:hover{background:#24314d}
    #err{display:none;position:fixed;right:10px;top:10px;z-index:11;background:#3b1a1a;border:1px solid #a55;color:#ffdede;padding:8px 10px;border-radius:8px;max-width:46vw;white-space:pre-wrap}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
<div id="hud">
  <div class="card">
    <div class="row">
      <span class="tag"><b>Isneique 4D</b></span>
      Espiral em torno de <b>D</b> : (−t, 1−t, t), avanço +2 por volta.
      Ao cruzar <b>A</b>: −2x+y−z=1 ou <b>B</b>: y+z=1 ⇒ <b>reflete</b> no plano <b>C</b>.
      <button class="btn" id="btnReset">Reiniciar</button>
    </div>
  </div>
  <div class="card" id="status">—</div>
  <div class="card mono" id="matC"></div>
</div>
<div id="err"></div>
<canvas id="c"></canvas>

<script>
(function(){
  // ---- overlay de erros (se algo quebrar, você vê o motivo) ---
  const errBox = document.getElementById('err');
  function showErr(e){ errBox.style.display='block'; errBox.textContent = String(e); console.error(e); }
  window.addEventListener('error', ev => showErr(ev.error || ev.message));

  try {
    // ========= cena =========
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b1020);
    const camera = new THREE.PerspectiveCamera(55, 2, 0.1, 1000); camera.position.set(8,6,11);
    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const dl = new THREE.DirectionalLight(0xffffff, 0.9); dl.position.set(6,12,8); scene.add(dl);
    scene.add(new THREE.AxesHelper(4));

    // ========= utils =========
    function matToString(m){
      const e=m.elements, get=(r,c)=>e[c*4+r]; let out='';
      for(let r=0;r<4;r++){ const row=[]; for(let c=0;c<4;c++) row.push((get(r,c)).toFixed(3).padStart(9)); out+='[ '+row.join(' ')+' ]\n'; }
      return out;
    }
    const T = (tx,ty,tz)=> new THREE.Matrix4().makeTranslation(tx,ty,tz);
    const R_axis = (axis,ang)=> new THREE.Matrix4().makeRotationAxis(axis.clone().normalize(), ang);
    const rotateAboutPoint = (axis,ang,P)=>
      new THREE.Matrix4().multiplyMatrices(T(P.x,P.y,P.z), new THREE.Matrix4().multiplyMatrices(R_axis(axis,ang), T(-P.x,-P.y,-P.z)));

    // ========= Planos A, B =========
    const fA = p => -2*p.x + p.y - p.z - 1;  // -2x+y-z=1
    const fB = p =>  p.y + p.z - 1;          //  y+z=1

    function addPlaneVisual(normal, d, color){
      // plano ax+by+cz+d=0 → ponto no plano: P = -d * n / ||n||^2
      const n = normal.clone();
      const P = n.clone().multiplyScalar(-d / n.lengthSq());
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(22,22),
        new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.12, side:THREE.DoubleSide })
      );
      const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), n.clone().normalize());
      mesh.position.copy(P); mesh.setRotationFromQuaternion(q);
      scene.add(mesh);
    }
    // A: nA=(-2,1,-1), dA=-1  |  B: nB=(0,1,1), dB=-1
    addPlaneVisual(new THREE.Vector3(-2,1,-1), -1, 0xff5555);
    addPlaneVisual(new THREE.Vector3(0,1,1),   -1, 0x55ff88);

    // ========= Plano C (a partir da forma paramétrica) =========
    // u=(-2,4,-2), v=(-1,-1,1) → n=(1,2,3) → x+2y+3z=2
    // Usaremos a forma homogênea (a,b,c,d) NORMALIZADA para a reflexão.
    const nC = new THREE.Vector3(1,2,3);
    const norm = nC.length();
    const au=1/norm, bu=2/norm, cu=3/norm, du=-2/norm;

    // Reflexão homogênea no plano ax+by+cz + d = 0 (a,b,c normalizados):
    // H = I - 2 * K,  onde K = [[a a, a b, a c, a d], ...; última linha zeros]
    function reflectionPlaneHomog(a,b,c,d){
      const K = new THREE.Matrix4().set(
        a*a, a*b, a*c, a*d,
        b*a, b*b, b*c, b*d,
        c*a, c*b, c*c, c*d,
        0,   0,   0,   0
      );
      const H = K.clone().multiplyScalar(-2);                 // -2K
      // adiciona identidade (como não vamos depender de .add em versões antigas, somo manualmente as diagonais):
      const e = H.elements;
      e[0]  += 1; e[5]  += 1; e[10] += 1; e[15] += 1;         // I - 2K
      return H;
    }
    const H_refC = reflectionPlaneHomog(au,bu,cu,du);
    document.getElementById('matC').textContent =
      'Plano C: x + 2y + 3z = 2 (n=(1,2,3))\nH_refC:\n' + matToString(H_refC);

    // ========= Eixo D: (-t, 1-t, t) =========
    const PD = new THREE.Vector3(0,1,0);                   // ponto do eixo
    const dDir = new THREE.Vector3(-1,-1,1).normalize();   // direção do eixo

    // vetor radial inicial e ponto-base (início da espiral)
    const tmp = new THREE.Vector3(0,1,0);
    if (Math.abs(tmp.dot(dDir))>0.99) tmp.set(1,0,0);
    const e1 = new THREE.Vector3().crossVectors(dDir, tmp).normalize();
    const r = 0.8;
    const basePoint = PD.clone().addScaledVector(e1, r);
    const T_base = T(basePoint.x, basePoint.y, basePoint.z);

    // avanço por volta: +2 → por ângulo θ, s = θ/π
    const spiralTransform = theta => {
      const s = theta / Math.PI;
      const Tadv = T(dDir.x*s, dDir.y*s, dDir.z*s);
      const R = rotateAboutPoint(dDir, theta, PD);
      return new THREE.Matrix4().multiplyMatrices(Tadv, R); // H_spiral = T_adv · R_D
    };

    // ========= objeto e trilha =========
    const snake = new THREE.Mesh(
      new THREE.PlaneGeometry(1,1),
      new THREE.MeshStandardMaterial({ color:0xffc857, side:THREE.DoubleSide, roughness:0.7 })
    );
    scene.add(snake);

    const trailGeom = new THREE.BufferGeometry();
    const trailPositions = new Float32Array(3*400);
    trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions,3));
    const trail = new THREE.Line(trailGeom, new THREE.LineBasicMaterial({ color:0x58a6ff }));
    scene.add(trail);
    let trailIndex = 0;

    // ========= estado/reflexões =========
    let H_acc = new THREE.Matrix4().identity();
    let countA = 0, countB = 0;
    let prevFA = null, prevFB = null;

    // ========= viewport =========
    function resize(){ const w=innerWidth,h=innerHeight; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); }
    function frameAll(pad=1.35){
      const box=new THREE.Box3().setFromObject(scene);
      const size=box.getSize(new THREE.Vector3()), center=box.getCenter(new THREE.Vector3());
      const maxSize=Math.max(size.x,size.y,size.z);
      const fitH=maxSize/(2*Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5)));
      const fitW=fitH/camera.aspect;
      const d=pad*Math.max(fitH,fitW);
      camera.position.set(center.x+d, center.y+d*0.6, center.z+d);
      camera.lookAt(center);
    }
    addEventListener('resize', ()=>{ resize(); frameAll(); });
    resize(); frameAll();

    // ========= animação =========
    const clock = new THREE.Clock();
    let theta = 0;
    const omega = 2.0; // rad/s

    function step(){
      const dt = clock.getDelta();
      theta += omega * dt;

      const Hs = spiralTransform(theta);               // helicoidal
      const Htotal = new THREE.Matrix4()
        .multiplyMatrices(H_acc, new THREE.Matrix4().multiplyMatrices(Hs, T_base));

      // posição atual do ponto-base (para checar planos)
      const Pcur = new THREE.Vector3(0,0,0)
        .applyMatrix4(T_base).applyMatrix4(Hs).applyMatrix4(H_acc);

      // cruzamentos A/B (troca de sinal)
      const fA_now = fA(Pcur), fB_now = fB(Pcur);
      if (prevFA !== null && fA_now*prevFA < 0){ H_acc = new THREE.Matrix4().multiplyMatrices(H_refC, H_acc); countA++; }
      if (prevFB !== null && fB_now*prevFB < 0){ H_acc = new THREE.Matrix4().multiplyMatrices(H_refC, H_acc); countB++; }
      prevFA = fA_now; prevFB = fB_now;

      // aplica no objeto
      snake.matrixAutoUpdate = false;
      snake.matrix.copy(Htotal);

      // trilha
      if (trailIndex < trailPositions.length/3){
        trailPositions[3*trailIndex+0] = Pcur.x;
        trailPositions[3*trailIndex+1] = Pcur.y;
        trailPositions[3*trailIndex+2] = Pcur.z;
        trailIndex++;
        trail.geometry.setDrawRange(0, trailIndex);
        trail.geometry.attributes.position.needsUpdate = true;
      } else {
        trailPositions.copyWithin(0,3);
        trailPositions[trailPositions.length-3] = Pcur.x;
        trailPositions[trailPositions.length-2] = Pcur.y;
        trailPositions[trailPositions.length-1] = Pcur.z;
        trail.geometry.attributes.position.needsUpdate = true;
      }

      // HUD
      document.getElementById('status').textContent =
        `θ=${theta.toFixed(2)} rad  •  voltas=${(theta/(2*Math.PI)).toFixed(2)}  •  cruzou A:${countA}  B:${countB}`;

      renderer.render(scene, camera);
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);

    // reset
    document.getElementById('btnReset').onclick = ()=>{
      theta=0; H_acc.identity(); countA=countB=0; prevFA=prevFB=null;
      trailIndex=0; trail.geometry.setDrawRange(0,0);
    };

  } catch(e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
