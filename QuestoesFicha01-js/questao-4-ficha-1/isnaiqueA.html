<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Isneique — Espiral em D + Reflexões por A/B no plano C</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;color:#e6edf3;font-family:system-ui,sans-serif}
    canvas{display:block}
    #hud{position:fixed;top:10px;left:10px;z-index:10;display:flex;gap:8px;flex-wrap:wrap;max-width:92vw}
    .card{background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.18);border-radius:10px;padding:8px 10px;font-size:13px;line-height:1.35}
    .btn{background:#1b2336;color:#e6edf3;border:1px solid #334;border-radius:8px;padding:6px 10px;cursor:pointer}
    .btn:hover{background:#24314d}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;white-space:pre;overflow:auto;max-height:26vh}
    #err{display:none;position:fixed;right:10px;top:10px;z-index:11;background:#3b1a1a;border:1px solid #a55;color:#ffdede;padding:8px 10px;border-radius:8px;max-width:46vw;white-space:pre-wrap}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="hud">
    <div class="card">
      <b>Isneique 4D</b> — Espiral em <b>D</b>; reflete em <b>C</b> ao cruzar <b>A</b>/<b>B</b>.
    </div>
    <div class="card" id="status">—</div>
    <div class="card mono" id="matC"></div>
    <!-- NOVO: botões de zoom -->
    <div class="card">
      <button class="btn" id="zoomIn">Zoom +</button>
      <button class="btn" id="zoomOut">Zoom −</button>
      <button class="btn" id="btnReset">Reiniciar</button>
    </div>
  </div>
  <div id="err"></div>
  <canvas id="c"></canvas>

<script>
(function(){
  const errBox = document.getElementById('err');
  function showErr(e){ errBox.style.display='block'; errBox.textContent=String(e); console.error(e); }
  window.addEventListener('error', ev => showErr(ev.error || ev.message));

  try{
    // ==== cena ====
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b1020);

    // ALTERADO: FOV menor (aproxima visualmente)
    const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 1000);
    camera.position.set(8,6,11);

    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const dl = new THREE.DirectionalLight(0xffffff, 0.9); dl.position.set(6,12,8); scene.add(dl);
    scene.add(new THREE.AxesHelper(4));

    // ==== helpers ====
    function matToString(m){ const e=m.elements, get=(r,c)=>e[c*4+r];
      let out=''; for(let r=0;r<4;r++){ const row=[]; for(let c=0;c<4;c++) row.push((get(r,c)).toFixed(3).padStart(9)); out+='[ '+row.join(' ')+' ]\n'; } return out; }
    const T=(tx,ty,tz)=>new THREE.Matrix4().makeTranslation(tx,ty,tz);
    const R_axis=(axis,ang)=>new THREE.Matrix4().makeRotationAxis(axis.clone().normalize(),ang);
    const rotateAboutPoint=(axis,ang,P)=>new THREE.Matrix4().multiplyMatrices(T(P.x,P.y,P.z),new THREE.Matrix4().multiplyMatrices(R_axis(axis,ang),T(-P.x,-P.y,-P.z)));

    // planos A/B (para detecção)
    const fA=p=>-2*p.x+p.y-p.z-1; const fB=p=>p.y+p.z-1;

    // desenha planos A/B (semitransp) só pra referência
    function addPlaneVisual(normal,d,color){
      const n=normal.clone(); const P=n.clone().multiplyScalar(-d/n.lengthSq());
      const mesh=new THREE.Mesh(new THREE.PlaneGeometry(22,22), new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.12,side:THREE.DoubleSide}));
      const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), n.clone().normalize());
      mesh.position.copy(P); mesh.setRotationFromQuaternion(q); scene.add(mesh);
    }
    addPlaneVisual(new THREE.Vector3(-2,1,-1),-1,0xff5555);
    addPlaneVisual(new THREE.Vector3(0,1,1),-1,0x55ff88);

    // plano C (reflexão): x+2y+3z=2
    const nC=new THREE.Vector3(1,2,3); const norm=nC.length();
    const au=1/norm, bu=2/norm, cu=3/norm, du=-2/norm;
    function reflectionPlaneHomog(a,b,c,d){
      const K=new THREE.Matrix4().set(a*a,a*b,a*c,a*d, b*a,b*b,b*c,b*d, c*a,c*b,c*c,c*d, 0,0,0,0);
      const H=K.clone().multiplyScalar(-2); const e=H.elements; e[0]+=1; e[5]+=1; e[10]+=1; e[15]+=1; return H;
    }
    const H_refC=reflectionPlaneHomog(au,bu,cu,du);
    document.getElementById('matC').textContent='Plano C: x + 2y + 3z = 2 (n=(1,2,3))\nH_refC:\n'+matToString(H_refC);

    // eixo D: (-t,1-t,t)
    const PD=new THREE.Vector3(0,1,0);
    const dDir=new THREE.Vector3(-1,-1,1).normalize();
    const tmp=new THREE.Vector3(0,1,0); if(Math.abs(tmp.dot(dDir))>0.99) tmp.set(1,0,0);
    const e1=new THREE.Vector3().crossVectors(dDir,tmp).normalize();
    const r=0.8;
    const basePoint=PD.clone().addScaledVector(e1,r);
    const T_base=T(basePoint.x,basePoint.y,basePoint.z);

    // helicoidal: +2 por volta => s=θ/π
    const spiralTransform=theta=>{
      const s=theta/Math.PI; const Tadv=T(dDir.x*s,dDir.y*s,dDir.z*s);
      const R=rotateAboutPoint(dDir,theta,PD);
      return new THREE.Matrix4().multiplyMatrices(Tadv,R);
    };

    // objeto e trilha
    const snake=new THREE.Mesh(new THREE.PlaneGeometry(1,1), new THREE.MeshStandardMaterial({color:0xffc857,side:THREE.DoubleSide,roughness:0.7}));
    scene.add(snake);
    const trailGeom=new THREE.BufferGeometry(); const trailPositions=new Float32Array(3*400);
    trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions,3));
    const trail=new THREE.Line(trailGeom, new THREE.LineBasicMaterial({color:0x58a6ff}));
    scene.add(trail); let trailIndex=0;

    // estado/reflexões
    let H_acc=new THREE.Matrix4().identity(); let countA=0,countB=0; let prevFA=null,prevFB=null;

    // ====== enquadramento/zoom ======
    // ALTERADO: zoomPad inicial mais próximo
    let zoomPad = 0.85;  // quanto menor, mais perto (ex.: 0.7 bem perto, 1.2 mais longe)

    function resize(){ const w=innerWidth,h=innerHeight; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); }
    function frameAll(pad=zoomPad){
      const box=new THREE.Box3().setFromObject(scene);
      const size=box.getSize(new THREE.Vector3()), center=box.getCenter(new THREE.Vector3());
      const maxSize=Math.max(size.x,size.y,size.z);
      const fitH=maxSize/(2*Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5)));
      const fitW=fitH/camera.aspect;
      const d=pad*Math.max(fitH,fitW);
      camera.position.set(center.x+d, center.y+d*0.55, center.z+d); // levemente mais baixo
      camera.lookAt(center);
    }
    addEventListener('resize', ()=>{ resize(); frameAll(); });
    resize(); frameAll();

    // Botões de zoom
    document.getElementById('zoomIn').onclick = ()=>{ zoomPad = Math.max(0.5, zoomPad-0.1); frameAll(); };
    document.getElementById('zoomOut').onclick= ()=>{ zoomPad = Math.min(2.0, zoomPad+0.1); frameAll(); };

    // ====== animação ======
    const clock=new THREE.Clock(); let theta=0; const omega=2.0;
    function step(){
      const dt=clock.getDelta(); theta+=omega*dt;
      const Hs=spiralTransform(theta);
      const Htotal=new THREE.Matrix4().multiplyMatrices(H_acc, new THREE.Matrix4().multiplyMatrices(Hs, T_base));

      // ponto atual
      const Pcur=new THREE.Vector3(0,0,0).applyMatrix4(T_base).applyMatrix4(Hs).applyMatrix4(H_acc);

      // reflexões
      const fA_now=fA(Pcur), fB_now=fB(Pcur);
      if(prevFA!==null && fA_now*prevFA<0){ H_acc=new THREE.Matrix4().multiplyMatrices(H_refC,H_acc); countA++; }
      if(prevFB!==null && fB_now*prevFB<0){ H_acc=new THREE.Matrix4().multiplyMatrices(H_refC,H_acc); countB++; }
      prevFA=fA_now; prevFB=fB_now;

      // aplica
      snake.matrixAutoUpdate=false; snake.matrix.copy(Htotal);

      // trilha
      if(trailIndex < trailPositions.length/3){
        trailPositions[3*trailIndex+0]=Pcur.x; trailPositions[3*trailIndex+1]=Pcur.y; trailPositions[3*trailIndex+2]=Pcur.z;
        trailIndex++; trail.geometry.setDrawRange(0, trailIndex); trail.geometry.attributes.position.needsUpdate=true;
      }else{
        trailPositions.copyWithin(0,3);
        trailPositions[trailPositions.length-3]=Pcur.x; trailPositions[trailPositions.length-2]=Pcur.y; trailPositions[trailPositions.length-1]=Pcur.z;
        trail.geometry.attributes.position.needsUpdate=true;
      }

      document.getElementById('status').textContent =
        `θ=${theta.toFixed(2)} rad • voltas=${(theta/(2*Math.PI)).toFixed(2)} • cruzou A:${countA} B:${countB}`;

      renderer.render(scene,camera);
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);

    // reset
    document.getElementById('btnReset').onclick=()=>{
      theta=0; H_acc.identity(); countA=countB=0; prevFA=prevFB=null;
      trailIndex=0; trail.geometry.setDrawRange(0,0);
      // volta pro zoom padrão mais perto
      zoomPad=0.85; frameAll();
    };

  }catch(e){ showErr(e); }
})();
</script>
</body>
</html>
